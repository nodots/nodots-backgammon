# Nodots Backgammon Project Rules

## Rules of Backgammon

https://www.bkgm.com/rules.html

## Backgammon Board Position System

**CRITICAL**: Each point on the backgammon board has TWO position numbers - one for each player direction:

- **Clockwise positions**: 1, 2, 3... 24 (clockwise player's perspective)
- **Counterclockwise positions**: 1, 2, 3... 24 (counterclockwise player's perspective)

### Starting Positions

- **Clockwise player** starts with checkers on clockwise positions: 24, 13, 8, 6
- **Counterclockwise player** starts with checkers on counterclockwise positions: 24, 13, 8, 6

### Key Points

- Both players start on their respective "24, 13, 8, 6" but from their own directional perspective
- This is NOT a bug - it's the correct dual numbering system
- Each point object contains: `{ clockwise: X, counterclockwise: Y }`
- Move validation must use the correct positional perspective for each player

### Example

```
Point at top-right of ASCII board:
- Clockwise position: 24 (WHITE's starting position)
- Counterclockwise position: 1 (BLACK's goal position)
```

This dual numbering system is essential for proper move validation and game logic.

## Unified Presentation Layer

**KEY FEATURE**: Every player sees the board as if they are "white moving clockwise" regardless of the actual backend configuration.

### Backend Flexibility

The game can have any combination of:

- White moving clockwise vs counterclockwise
- Black moving clockwise vs counterclockwise
- Any player being human or robot
- Any starting positions

### Frontend Consistency

Every player always sees:

- Their checkers as "white" moving clockwise
- Their home board as positions 1-6 (bottom right)
- Their outer board as positions 7-12 (bottom left)
- Opponent's outer board as positions 13-18 (top left)
- Opponent's home board as positions 19-24 (top right)

### Benefits

- Eliminates cognitive load of "which direction am I moving?"
- No need to mentally flip the board
- Consistent, intuitive view for all players
- Backend can handle any game configuration while frontend presents unified experience

This presentation abstraction is a key differentiator of Nodots Backgammon.

# Cursor Rules

- **Regular Status Updates**: Provide status updates every 15 seconds during long-running tasks or operations. Each update MUST include:

  - üïí Timestamp in format "**[HH:MM:SS] UPDATE #N**"
  - Current task/operation being performed
  - Progress indicators or completion status
  - Any issues encountered
  - Next steps planned
    This keeps the user informed and prevents confusion about task progress.

- **Notification Requirements**: Update status in the chat window at a minimum ever 30 seconds. If you are stuck, interrupt after 3 iterations.

- **Stuck Detection**: If I spend more than 2 minutes on infrastructure issues, debugging environment problems, or repeatedly failing at the same task without making progress toward the user's actual goal, I MUST notify the user immediately with:

  - "‚ö†Ô∏è **I'M STUCK**: [brief description of what I'm stuck on]"
  - "üéØ **SUGGESTED APPROACH**: [alternative approach]"
  - "‚ùì **USER INPUT NEEDED**: [what decision or help I need]"
    This prevents wasting time on tangential issues and keeps focus on the main objective.

- **API Server Management**: ALWAYS kill existing API server processes before starting the server. Multiple running instances cause port conflicts and unpredictable behavior. Before starting the API server:

  1. Navigate to `nodots-backgammon-api` directory
  2. Run `npm run kill-port` to kill processes on port 3000 (uses the package.json script)
  3. Check for any remaining ts-node/nodemon processes with `ps aux | grep -E "(ts-node|nodemon)" | grep -v grep`
  4. Kill any remaining processes if found
  5. Start the server with `npm start` (not npm run dev - that script doesn't exist)
     This prevents port conflicts, ensures clean server state, and avoids multiple concurrent API instances that can cause simulation hangs.

- **Test Requirements**: All tests must pass before reporting that a task is completed. If any tests fail after implementing changes, iterate on the solution until all tests pass. Run the test suite and fix any failures before considering the task done.

- **Directory Verification**: ALWAYS verify the current directory before running terminal commands. Use `pwd` or check the last terminal cwd to ensure you're in the correct directory (e.g., nodots-backgammon-api for API commands, nodots-backgammon-core for core commands). If in the wrong directory, navigate to the correct one before executing commands. This prevents file not found errors and ensures commands run in the intended context.

- **Bug Status Clarity**: When reporting on bugs, be explicitly clear about the current status using these exact terms:

  - "üîç **BUG DISCOVERED**" - when a bug has been found and documented but not yet fixed
  - "üîß **BUG FIXED**" - when a bug has been resolved and verified through testing
  - "üß™ **BUG INVESTIGATION**" - when actively debugging but root cause not yet identified
  - "‚úÖ **BUG VERIFIED RESOLVED**" - when fix has been tested and confirmed working
    Never use ambiguous language that could confuse discovery with resolution.

- **Play/Move Game Flow**: Understanding the critical game flow is essential for debugging move-related issues:

  1. **Game.roll()** creates new Play instance ‚Üí becomes activePlay in Game
  2. **Play.initialize()** creates moves (2 for regular roll, 4 for doubles) with possibleMoves populated
  3. **Empty possibleMoves** = 'no-move', completed automatically
  4. **Non-empty possibleMoves** = player selects from options (humans click checkers, robots auto-select first)
  5. **Move execution** updates activePlay.moves to track consumed dice
     When debugging move issues, always check: activePlay state, moves array, possibleMoves population, and dice consumption tracking.

- **Game Logic Separation**: ALL game logic must reside in nodots-backgammon-core. The API layer should ONLY:
  1. Accept information about current state and proposed state changes
  2. Pass these to core for validation and execution
  3. Return results or errors from core
  4. Handle persistence and API concerns
     Never implement game rules, move validation, or game state logic in the API layer. This separation ensures consistency and testability.

## API Server

The API server routes are <hostname>:<port>/api/v1/<route>
